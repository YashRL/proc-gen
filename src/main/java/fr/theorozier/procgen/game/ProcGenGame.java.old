package fr.theorozier.procgen.game;

import fr.theorozier.procgen.util.MathUtils;
import fr.theorozier.procgen.world.World;
import io.msengine.client.game.DefaultRenderGame;
import io.msengine.client.game.RenderGameOptions;
import io.msengine.client.renderer.basic.Basic3DShaderManager;
import io.msengine.client.renderer.model.ModelApplyListener;
import io.msengine.client.renderer.model.ModelHandler;
import io.msengine.client.renderer.util.BufferType;
import io.msengine.client.renderer.util.BufferUsage;
import io.msengine.client.renderer.vertex.IndicesDrawBuffer;
import io.msengine.client.renderer.vertex.type.BasicFormat;
import io.msengine.client.renderer.window.Window;
import io.msengine.client.renderer.window.listener.WindowFramebufferSizeEventListener;
import org.joml.Matrix4f;
import org.lwjgl.glfw.GLFW;

import static org.lwjgl.opengl.GL11.*;

public class ProcGenGame extends DefaultRenderGame<ProcGenGame> implements ModelApplyListener, WindowFramebufferSizeEventListener {
	
	private final Basic3DShaderManager sm3d;
	private final ModelHandler model;
	
	private IndicesDrawBuffer db;
	
	private final Matrix4f globalMatrix;
	private final Matrix4f projectionMatrix;
	private Matrix4f modelMatrix;
	
	private float scale = 10f;
	private int octaves = 6;
	private float persistance = 0.4f;
	private float lacunarity = 1.5f;
	
	private int vertSize  = 100;
	private int tileSize  = vertSize - 1;
	
	private int vertCount = vertSize * vertSize;
	private int tileCount = tileSize * tileSize;
	
	private final float[][] noiseMap = new float[vertSize][vertSize];
	
	private final World testWorld;
	
	public ProcGenGame(RenderGameOptions options) {
		
		super(options);
		
		this.sm3d = new Basic3DShaderManager("sm3d");
		this.model = new ModelHandler(this);
		
		this.db = null;
		
		this.projectionMatrix = new Matrix4f();
		this.globalMatrix = new Matrix4f();
		this.modelMatrix = null;
		
		this.testWorld = new World();
		
	}
	
	@Override
	protected void init() {
		
		super.init();
		
		this.sm3d.build();
		this.db = this.sm3d.createBasicDrawBuffer(true, false);
		
		this.window.addFramebufferSizeEventListener(this);
		this.updateRenderSize(this.window);
		
		this.initMapBuffer();
		
		this.testWorld.loadNear(0, 64, 0);
		
		glDisable(GL_CULL_FACE);
		glEnable(GL_DEPTH_TEST);
		
		glClearColor(0f, 0f, 0f, 1f);
		
	}
	
	public void initMapBuffer() {
		
		this.db.bindVao();
		this.db.allocateVboData(BasicFormat.BASIC3D_POSITION, vertCount * 3 * 4, BufferUsage.DYNAMIC_DRAW);
		this.db.allocateVboData(BasicFormat.BASIC_COLOR, vertCount * 4 * 4, BufferUsage.DYNAMIC_DRAW);
		
		BufferType.INT.alloc(this.db.setIndicesCount(tileCount * 6), buf -> {
			
			for (int x = 0; x < tileSize; x++) {
				for (int z = 0; z < tileSize; z++) {
					
					int vi = z + x * vertSize;
					int vy = z + (x + 1) * vertSize;
					
					buf.put(vi).put(vi + 1).put(vy);
					buf.put(vi + 1).put(vy + 1).put(vy);
					
				}
			}
			
			buf.flip();
			
			this.db.uploadIboData(buf, BufferUsage.STATIC_DRAW);
			
		});
		
		this.computeMap();
		
	}
	
	public void computeMap() {
		
		float minNoise = Float.MAX_VALUE;
		float maxNoise = 0f;
		
		for (int x = 0; x < vertSize; x++) {
			for (int z = 0; z < vertSize; z++) {
				
				noiseMap[x][z] = MathUtils.simplexOctaves(x / this.scale, z/ this.scale, this.octaves, this.persistance, this.lacunarity);
				
				if (noiseMap[x][z] > maxNoise) {
					maxNoise = noiseMap[x][z];
				} else if (noiseMap[x][z] < minNoise) {
					minNoise = noiseMap[x][z];
				}
				
			}
		}
		
		for (int x = 0; x < vertSize; x++) {
			for (int z = 0; z < vertSize; z++) {
				noiseMap[x][z] = MathUtils.invlerp(minNoise, maxNoise, noiseMap[x][z]);
			}
		}
		
		this.db.bindVao();
		
		BufferType.FLOAT.alloc(vertCount * 3, buf -> {
			
			for (int x = 0; x < vertSize; x++) {
				for (int z = 0; z < vertSize; z++) {
					buf.put(x).put(noiseMap[x][z] * 30f).put(-z);
				}
			}
			
			buf.flip();
			
			this.db.uploadVboSubData(BasicFormat.BASIC3D_POSITION, 0, buf);
			
		});
		
		BufferType.FLOAT.alloc(vertCount * 4, buf -> {
			
			for (int x = 0; x < vertSize; x++) {
				for (int z = 0; z < vertSize; z++) {
					
					float greyscale = noiseMap[x][z];
					buf.put(greyscale).put(greyscale).put(greyscale).put(1f);
					
				}
			}
			
			buf.flip();
			
			this.db.uploadVboSubData(BasicFormat.BASIC_COLOR, 0, buf);
			
		});
		
	}
	
	@Override
	protected void stop() {
		
		this.db.delete();
		this.sm3d.delete();
		
		super.stop();
		
	}
	
	@Override
	protected void render(float alpha) {
		
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		
		// this.guiManager.render(alpha);
		
		this.sm3d.use();
		
		final float rtime = (float) this.window.getTime();
		
		this.model.push().translate(-5f, -2f, -5f).rotateX((float) Math.toRadians(40f)).scale(0.1f).apply();
		this.db.drawElements();
		this.model.pop();
		
		this.sm3d.end();
		
	}
	
	@Override
	protected void update() {
		
		if (this.window.isKeyPressed(GLFW.GLFW_KEY_F1)) {
			
			this.scale -= 0.1f;
			this.computeMap();
			System.out.println("Scale : " + this.scale);
			
		} else if (this.window.isKeyPressed(GLFW.GLFW_KEY_F2)) {
			
			this.scale += 0.1f;
			this.computeMap();
			System.out.println("Scale : " + this.scale);
			
		} else if (this.window.isKeyPressed(GLFW.GLFW_KEY_F3)) {
			
			this.octaves -= 1;
			this.computeMap();
			System.out.println("Octaves : " + this.octaves);
			
		} else if (this.window.isKeyPressed(GLFW.GLFW_KEY_F4)) {
			
			this.octaves += 1;
			this.computeMap();
			System.out.println("Octaves : " + this.octaves);
			
		} else if (this.window.isKeyPressed(GLFW.GLFW_KEY_F5)) {
			
			this.persistance -= 0.01f;
			this.computeMap();
			System.out.println("Persistance : " + this.persistance);
			
		} else if (this.window.isKeyPressed(GLFW.GLFW_KEY_F6)) {
			
			this.persistance += 0.01f;
			this.computeMap();
			System.out.println("Persistance : " + this.persistance);
			
		} else if (this.window.isKeyPressed(GLFW.GLFW_KEY_F7)) {
			
			this.lacunarity -= 0.01f;
			this.computeMap();
			System.out.println("Lacunarity : " + this.lacunarity);
			
		} else if (this.window.isKeyPressed(GLFW.GLFW_KEY_F8)) {
			
			this.lacunarity += 0.01f;
			this.computeMap();
			System.out.println("Lacunarity : " + this.lacunarity);
			
		}
		
		// this.guiManager.update();
	
	}
	
	private void updateGlobalMatrix() {
		
		this.globalMatrix.set(this.projectionMatrix);
		
		if (this.modelMatrix != null)
			this.globalMatrix.mul(this.modelMatrix);
		
		this.sm3d.setGlobalMatrix(this.globalMatrix);
		
	}
	
	@Override
	public void modelApply(Matrix4f model) {
		
		this.modelMatrix = model;
		this.updateGlobalMatrix();
		
	}
	
	private void updateRenderSize(int width, int height) {
		
		glViewport(0,0, width, height);
		
		this.projectionMatrix.identity();
		this.projectionMatrix.perspective((float) Math.toRadians(70f), (float) width / (float) height, 0.1f, 100f);
		this.updateGlobalMatrix();
		
	}
	
	private void updateRenderSize(Window window) {
		this.updateRenderSize(window.getWidth(), window.getHeight());
	}
	
	@Override
	public void windowFramebufferSizeChangedEvent(int width, int height) {
		this.updateRenderSize(width, height);
	}
	
}
